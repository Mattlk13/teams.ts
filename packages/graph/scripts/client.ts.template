{{#if (eq url "/")}}
import type { CallOptions, EndpointRequest } from './common';
import { getInjectedUrl } from '@utils/url';
{{else if (notEmpty endpoints)}}
import { getInjectedUrl } from '@utils/url';
{{/if}}
import * as http from '@microsoft/teams.common/http';

import pkg from 'src/../package.json';
{{#if (notEmpty endpoints)}}
import type { Endpoints } from './{{types}}-types.ts';
{{/if}}
{{#each clients}}
import { {{capitalize @key}}Client } from './{{@key}}';
{{/each}}

/**
 * {{url}}
 {{#if description}}
 * {{description}}
 {{/if}}
 */
export class {{capitalize name}}Client {
  protected baseUrl = '{{url}}';
  protected http: http.Client;

  {{#if (notEmpty parameters)}}
  constructor(
    {{#each parameters}}protected readonly {{camelcase this}}: string,{{/each}}
    options?: http.Client | http.ClientOptions
  ) {
  {{else}}
  constructor(options?: http.Client | http.ClientOptions) {
  {{/if}}
    if (!options) {
      this.http = new http.Client({
        baseUrl: 'https://graph.microsoft.com/v1.0',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': `teams.ts[graph]/${pkg.version}`
        }
      });
    } else if ('request' in options) {
      this.http = options.clone({
        baseUrl: 'https://graph.microsoft.com/v1.0',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': `teams.ts[graph]/${pkg.version}`,
        }
      });
    } else {
      this.http = new http.Client({
        ...options,
        baseUrl: 'https://graph.microsoft.com/v1.0',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': `teams.ts[graph]/${pkg.version}`,
          ...options.headers
        }
      });
    }
  }

{{#if (eq url "/")}}
  /**
   * Executes a Graph API endpoint function with optional HTTP configuration
   * 
   * @param func - The endpoint function to execute
   * @param args - Arguments for the endpoint function, optionally followed by {@link CallConfig}
   * @returns Promise resolving to the endpoint's response data
    * 
    * @example
    * ```typescript
    * // Simple call
    * const user = await client.call(endpoints.users.get, 'user-id');
    * 
    * // With HTTP configuration
    * const user = await client.call(endpoints.users.get, 'user-id', {
    *   requestConfig: { 
    *     timeout: 5000 
    *   }
    * });
    * ```
  */
  async call<
    F extends (...args: any[]) => EndpointRequest<any>,
    R = ReturnType<F> extends EndpointRequest<infer T> ? T : never,
  >(
    func: F, 
    ...args: [...Parameters<F>, CallOptions?]
  ): Promise<R> {
    // Check if last arg is a config object
    const lastArg = args[args.length - 1];
    const hasOptions = 
      args.length > func.length && 
      lastArg && 
      typeof lastArg === 'object' && 
      'requestConfig' in lastArg;
    
    // Extract function arguments
    const funcArgs = hasOptions 
      ? args.slice(0, -1)
      : args;
    
    const requestConfig = hasOptions ? (lastArg as CallOptions).requestConfig : undefined;

    const { method, path, paramDefs, params, body } = func(...funcArgs as any[]);
    const url = getInjectedUrl(path, paramDefs, params || {});

    switch (method) {
      case 'delete':
      case 'get':
        return (await this.http[method](url, requestConfig)).data as R;
      case 'patch':
      case 'post':
      case 'put':
        return (await this.http[method](url, body, requestConfig)).data as R;
      default:
        throw new Error(`Unsupported HTTP method: ${method}`);
    }
  }
{{/if}}

  {{#each clients}}
  /**
   * `{{url}}`
   *
   {{#if description}}
   * {{description}}
   {{/if}}
   */
  {{#if (notEmpty parameters)}}
  {{@key}}({{#each parameters}}{{camelcase this}}: string,{{/each}}) {
    return new {{capitalize @key}}Client(
      {{#each parameters}}{{camelcase this}},{{/each}}
      this.http
    );
  }
  {{else}}
  get {{@key}}() {
    return new {{capitalize @key}}Client(this.http);
  }
  {{/if}}

  {{/each}}

  {{#each endpoints}}
  /**
   * `{{uppercase method}} {{url}}`
   *
  {{#if description}}
   * {{description}}
  {{/if}}
   */
  {{#if (eq method "get")}}
  async {{name}}(params?: Endpoints['{{@key}}']['parameters'], config?: http.RequestConfig) {
    const url = getInjectedUrl(
      '{{url}}',
      [
        {{#if (notEmpty parameters)}}
        {{#each parameters}}
        { name: '{{name}}', in: '{{in}}' },
        {{/each}}
        {{/if}}
      ],
      {
        ...(params || { }),
        {{#if (notEmpty ../parameters)}}
        {{#each ../parameters}}'{{this}}': this.{{camelcase this}},{{/each}}
        {{/if}}
      },
    );

    return this.http.get(url, config).then(res => res.data as Endpoints['{{@key}}']['response']);
  }
  {{else if (eq method "delete")}}
  async {{name}}(params?: Endpoints['{{@key}}']['parameters'], config?: http.RequestConfig) {
    const url = getInjectedUrl(
      '{{url}}',
      [
        {{#if (notEmpty parameters)}}
        {{#each parameters}}
        { name: '{{name}}', in: '{{in}}' },
        {{/each}}
        {{/if}}
      ],
      {
        ...(params || { }),
        {{#if (notEmpty ../parameters)}}
        {{#each ../parameters}}'{{this}}': this.{{camelcase this}},{{/each}}
        {{/if}}
      },
    );

    return this.http.delete(url, config).then(res => res.data as Endpoints['{{@key}}']['response']);
  }
  {{else}}
  async {{name}}(
    body: Endpoints['{{@key}}']['body'],
    params?: Endpoints['{{@key}}']['parameters'],
    config?: http.RequestConfig
  ) {
    const url = getInjectedUrl(
      '{{url}}',
      [
        {{#if (notEmpty parameters)}}
        {{#each parameters}}
        { name: '{{name}}', in: '{{in}}' },
        {{/each}}
        {{/if}}
      ],
      {
        ...(params || { }),
        {{#if (notEmpty ../parameters)}}
        {{#each ../parameters}}'{{this}}': this.{{camelcase this}},{{/each}}
        {{/if}}
      },
    );

    return this.http.{{method}}(url, body, config).then(res => res.data as Endpoints['{{@key}}']['response']);
  }
  {{/if}}

  {{/each}}
}
